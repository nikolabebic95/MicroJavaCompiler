package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;


parser code {:

	int printCallCount = 0;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, COMMA, PRINT, RETURN, PLUS, EQUAL, VOID;
terminal Integer NUMBER ;
terminal String IDENT ;
terminal IF, ELSE;

non terminal Program Program;
nonterminal VarDeclList VarDeclList;
nonterminal MethodDeclList MethodDeclList;
nonterminal VarDecl VarDecl;
nonterminal Type Type;
nonterminal MethodDecl MethodDecl;
non terminal FormalParamList FormalParamList;
nonterminal FormalParamDecl FormalParamDecl;
nonterminal FormPars FormPars;
nonterminal ActualPars ActualPars;
nonterminal ActualParamList ActualParamList;
non terminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal Designator Designator;
nonterminal Expr Expr;
nonterminal Term Term;
nonterminal Addop Addop;
nonterminal Factor Factor;
non terminal Unmatched Unmatched;
nonterminal Matched Matched;


Program ::= PROG IDENT:I1 VarDeclList:V2 LBRACE MethodDeclList:M3 RBRACE {: RESULT=new ProgramDerived1(I1, V2, M3); RESULT.setLine(I1left); :} ;

VarDeclList ::= VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclListDerived1(V1, V2); RESULT.setLine(V1left); :}
				| {: RESULT=new VarDeclListDerived2(); :}
				/* epsilon */
				;

VarDecl ::= Type:T1 IDENT:I2 SEMI {: RESULT=new VarDeclDerived1(T1, I2); RESULT.setLine(T1left); :} ;

Type ::= IDENT:I1 {: RESULT=new TypeDerived1(I1); RESULT.setLine(I1left); :} ;

MethodDeclList ::= MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclListDerived1(M1, M2); RESULT.setLine(M1left); :}
					| {: RESULT=new MethodDeclListDerived2(); :}
					/* epsilon */
					;

MethodDecl ::= Type:T1 IDENT:I2 LPAREN FormPars:F3 RPAREN VarDeclList:V4 LBRACE StatementList:S5 RBRACE {: RESULT=new MethodDeclDerived1(T1, I2, F3, V4, S5); RESULT.setLine(T1left); :} ;

FormPars ::= FormalParamList:F1 {: RESULT=new FormParsDerived1(F1); RESULT.setLine(F1left); :} | {: RESULT=new FormParsDerived2(); :} /* epsilon */ ;

FormalParamList ::= FormalParamList:F1 COMMA FormalParamDecl:F2 {: RESULT=new FormalParamListDerived1(F1, F2); RESULT.setLine(F1left); :}
					|
					FormalParamDecl:F1 {: RESULT=new FormalParamListDerived2(F1); RESULT.setLine(F1left); :}
					;

FormalParamDecl ::= Type:T1 IDENT:I2 {: RESULT=new FormalParamDeclDerived1(T1, I2); RESULT.setLine(T1left); :} ;

StatementList ::= StatementList:S1 Statement:S2 {: RESULT=new StatementListDerived1(S1, S2); RESULT.setLine(S1left); :}
					| {: RESULT=new StatementListDerived2(); :}
				  /* epsilon */
				  ;

Statement ::= Matched:M1 {: RESULT=new StatementDerived1(M1); RESULT.setLine(M1left); :} | Unmatched:U1 {: RESULT=new StatementDerived2(U1); RESULT.setLine(U1left); :} ;

Unmatched ::= IF Expr:E1 Statement:S2 {: RESULT=new UnmatchedDerived1(E1, S2); RESULT.setLine(E1left); :} | IF Expr:E1 Matched:M2 ELSE Unmatched:U3 {: RESULT=new UnmatchedDerived2(E1, M2, U3); RESULT.setLine(E1left); :};


Matched ::= Designator:D1 EQUAL Expr:E2 SEMI {: RESULT=new MatchedDerived1(D1, E2); RESULT.setLine(D1left); :}
			  |
			  Designator:D1 EQUAL error SEMI
			  {: parser.log.debug("Uspesan oporavak od greske pri dodeli vrednosti."); :} {: RESULT=new MatchedDerived2(D1); RESULT.setLine(D1left); :}
			  |
			  PRINT LPAREN Expr:E1 RPAREN SEMI
			  {: parser.printCallCount++; :} {: RESULT=new MatchedDerived3(E1); RESULT.setLine(E1left); :}
			  |
			  RETURN Expr:E1 SEMI {: RESULT=new MatchedDerived4(E1); RESULT.setLine(E1left); :}
			  |
			  RETURN SEMI {: RESULT=new MatchedDerived5(); :}
			  |
			  IF Expr:E1 Matched:M2 ELSE Matched:M3 {: RESULT=new MatchedDerived6(E1, M2, M3); RESULT.setLine(E1left); :}
			  ;

Expr ::= Expr:E1 Addop:A2 Term:T3 {: RESULT=new ExprDerived1(E1, A2, T3); RESULT.setLine(E1left); :}
		 |
		 Term:T1 {: RESULT=new ExprDerived2(T1); RESULT.setLine(T1left); :}
		 ;

Term ::= Factor:F1 {: RESULT=new TermDerived1(F1); RESULT.setLine(F1left); :} ;

Factor ::= NUMBER:N1 {: RESULT=new FactorDerived1(N1); RESULT.setLine(N1left); :}
			|
		   Designator:D1 {: RESULT=new FactorDerived2(D1); RESULT.setLine(D1left); :}
		    |
		   Designator:D1 LPAREN ActualPars:A2 RPAREN {: RESULT=new FactorDerived3(D1, A2); RESULT.setLine(D1left); :}
		   ;

ActualPars ::= ActualParamList:A1 {: RESULT=new ActualParsDerived1(A1); RESULT.setLine(A1left); :}
				| {: RESULT=new ActualParsDerived2(); :}
			   /* epsilon */
			   ;

ActualParamList ::= ActualParamList:A1 COMMA Expr:E2 {: RESULT=new ActualParamListDerived1(A1, E2); RESULT.setLine(A1left); :}
					|
					Expr:E1 {: RESULT=new ActualParamListDerived2(E1); RESULT.setLine(E1left); :}
					;

Designator ::= IDENT:I1 {: RESULT=new DesignatorDerived1(I1); RESULT.setLine(I1left); :} ;

Addop ::= PLUS {: RESULT=new AddopDerived1(); :} ;

